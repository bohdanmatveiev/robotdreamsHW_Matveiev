Завдання 1. 
за допомогою vagrantfile було розгорнуто 2 віртуальні машини - сервер і клієнт

після запуску vm командою vagrant up підключився до сервера і клієнту з двох різних bash терміналів - vagrant ssh server
vagrant ssh client

використовуючи команду nc -l -p 1234 на сервері і команду nc 192.168.56.10 1234 на клієнті встановив tcp з'єднання.
надсилаючи повідомлення на сервері, успішно отримував його на клієнті і навпаки. за допомогою ctrl + c розірвав з'єднання.

після цього за допомогою команди nc -l -u -p 1234 на сервері і команди nc -u 192.168.56.10 1234 на клієнті встановив udp з'єднання
аналогічно відправляв між сервером і клієнтом повідомлення, надходили вони успішно.

відмінності TCP та UDP
TCP встановлює з’єднання, гарантує доставку та порядок повідомлень.
UDP не встановлює з’єднання, не гарантує доставку, пакети можуть губитися або приходити не в тому порядку.

блокування порту брандмауером
На сервері увімкнув ufw (sudo ufw enable), додав правило sudo ufw deny 1234, яке блокує всі вхідні з’єднання на порт 1234, перезапустив брандмауер (sudo ufw reload). після цього при спробі TCP-з’єднання клієнт не зміг підключитися — з’єднання не встановлюється, бо TCP потребує підтвердження.
при спробі UDP-з’єднання клієнт міг надсилати пакети, але сервер їх не отримував — пакети губилися без повідомлення про помилку.

Завдання 2. на машині server встановив пакет dnsmaq, в /etc/dnsmasq.conf відредагував конфігурацію, додавши
listen-address=127.0.0.1,192.168.56.10
server=8.8.8.8
address=/mytest.local/192.168.56.10
і перезапустив - 
sudo systemctl restart dnsmasq
після цього на клієнті за допомогою команди dig @192.168.56.10 mytest.local перевірив чи коректно все працює, у відповідь отримав від dns-серверу ip адресу, яку я задавав в конфігурації (dig_dns_test.log)
щодо процесу резолюції доменних імен: коли клієнт вводить домен (наприклад, mytest.local), його система звертається до налаштованого DNS-сервера, dnsmasq перевіряє свої локальні правила: якщо домен знайдено у конфігурації (address=/...), він одразу повертає IP, якщо домен не знайдено, dnsmasq пересилає запит на зовнішній DNS (наприклад, Google DNS 8.8.8.8), клієнт отримує IP-адресу і може встановити з’єднання з потрібним сервером.

Завдання 3. У компанії використовується велика мережа 10.0.0.0/8. Це означає, що в ній є понад 16 мільйонів адрес, бо маска /8 залишає 24 біти для хостів (2^24 = 16 777 216).
Колеги вже зайняли дві підмережі:
10.0.1.0/24 (256 адрес)
10.0.0.32/26 (64 адреси)
Мені потрібно було виділити 10 підмереж, у кожній з яких можна розмістити від 5 до 11 хостів.
Щоб визначити розмір підмережі, я використав формулу:
кількість хостів = 2^(32 – маска) – 2
/29 дає тільки 6 хостів (замало).
/28 дає 14 хостів (підходить, бо це більше ніж 11).
Отже, я вибрав маску /28. Це підмережі по 16 адрес, з яких 14 доступні для хостів.
Приклад 10 підмереж (уникаючи зайнятих діапазонів):
10.0.0.0/28 → хости 10.0.0.1 – 10.0.0.14
10.0.0.16/28 → хости 10.0.0.17 – 10.0.0.30
10.0.0.48/28 → хости 10.0.0.49 – 10.0.0.62
10.0.0.64/28 → хости 10.0.0.65 – 10.0.0.78
10.0.0.80/28 → хости 10.0.0.81 – 10.0.0.94
10.0.0.96/28 → хости 10.0.0.97 – 10.0.0.110
10.0.0.112/28 → хости 10.0.0.113 – 10.0.0.126
10.0.0.128/28 → хости 10.0.0.129 – 10.0.0.142
10.0.0.144/28 → хости 10.0.0.145 – 10.0.0.158
10.0.0.160/28 → хости 10.0.0.161 – 10.0.0.174
Таким чином, я отримав 10 підмереж, кожна з яких може вмістити від 5 до 11 хостів.
